import type { EventEmitter } from 'eventemitter3';
import type { AirtopClient } from '../../wrapper/AirtopClient';
import type { AirtopSessionConfigV1 } from '../../wrapper/AirtopSessions';
import type { BatchOperationError, BatchOperationInput, BatchOperationResponse, BatchOperationUrl } from './types';
export declare class SessionQueue<T> {
    private activePromises;
    private activePromisesMutex;
    private maxConcurrentSessions;
    private runEmitter;
    private maxWindowsPerSession;
    private sessionConfig?;
    private initialBatches;
    private operation;
    private onError?;
    private isHalted;
    private batchQueue;
    private batchQueueMutex;
    private latestProcessingPromise;
    private processingPromisesCount;
    private client;
    private sessionPool;
    private sessionPoolMutex;
    private results;
    constructor({ maxConcurrentSessions, runEmitter, maxWindowsPerSession, initialBatches, operation, client, sessionConfig, onError, }: {
        maxConcurrentSessions: number;
        runEmitter: EventEmitter;
        maxWindowsPerSession: number;
        initialBatches: BatchOperationUrl[][];
        operation: (input: BatchOperationInput) => Promise<BatchOperationResponse<T>>;
        client: AirtopClient;
        sessionConfig?: AirtopSessionConfigV1;
        onError?: (error: BatchOperationError) => Promise<void>;
    });
    handleHaltEvent(): void;
    addUrlsToBatchQueue(newBatch: BatchOperationUrl[]): Promise<void>;
    processInitialBatches(): Promise<void>;
    waitForProcessingToComplete(): Promise<T[]>;
    private terminateAllSessions;
    private processPendingBatches;
    private handleErrorWithCallback;
    private logErrorForUrls;
    private safelyTerminateSession;
    private formatError;
    private handleErrorAndWarningResponses;
}
