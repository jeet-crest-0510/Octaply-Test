"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionQueue = void 0;
const async_mutex_1 = require("async-mutex");
const WindowQueue_1 = require("./WindowQueue");
const helpers_1 = require("./helpers");
class SessionQueue {
    constructor({ maxConcurrentSessions, runEmitter, maxWindowsPerSession, initialBatches, operation, client, sessionConfig, onError, }) {
        this.activePromises = [];
        this.activePromisesMutex = new async_mutex_1.Mutex();
        this.initialBatches = [];
        this.batchQueue = [];
        this.batchQueueMutex = new async_mutex_1.Mutex();
        this.latestProcessingPromise = null;
        this.processingPromisesCount = 0;
        this.sessionPool = [];
        this.sessionPoolMutex = new async_mutex_1.Mutex();
        if (!Number.isInteger(maxConcurrentSessions) || maxConcurrentSessions <= 0) {
            throw new Error('maxConcurrentSessions must be a positive integer');
        }
        this.maxConcurrentSessions = maxConcurrentSessions;
        this.runEmitter = runEmitter;
        this.maxWindowsPerSession = maxWindowsPerSession;
        this.sessionConfig = sessionConfig;
        this.initialBatches = initialBatches;
        this.operation = operation;
        this.onError = onError;
        this.latestProcessingPromise = null;
        this.results = [];
        this.client = client;
        this.isHalted = false;
    }
    handleHaltEvent() {
        this.client.log('Halt event received');
        this.isHalted = true;
    }
    addUrlsToBatchQueue(newBatch) {
        return __awaiter(this, void 0, void 0, function* () {
            // Distribute new URLs across batches
            const newBatches = (0, helpers_1.distributeUrlsToBatches)(newBatch, this.maxConcurrentSessions);
            this.client.log(`Adding new batches to queue: ${JSON.stringify(newBatches)}`);
            // Add new batches to the queue
            yield this.batchQueueMutex.runExclusive(() => {
                this.batchQueue.push(...newBatches);
            });
            // Update existing processing promise
            this.processingPromisesCount++;
            this.latestProcessingPromise = this.processPendingBatches();
        });
    }
    processInitialBatches() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.batchQueueMutex.runExclusive(() => {
                this.batchQueue = [...this.initialBatches];
            });
            this.processingPromisesCount++;
            this.runEmitter.on('halt', this.handleHaltEvent.bind(this));
            this.latestProcessingPromise = this.processPendingBatches();
            yield this.latestProcessingPromise;
        });
    }
    waitForProcessingToComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.processingPromisesCount > 0) {
                yield this.latestProcessingPromise;
            }
            yield this.terminateAllSessions();
            this.runEmitter.removeListener('halt', this.handleHaltEvent);
            return this.results;
        });
    }
    terminateAllSessions() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const sessionId of this.sessionPool) {
                this.safelyTerminateSession(sessionId);
            }
        });
    }
    processPendingBatches() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                while (this.batchQueue.length > 0) {
                    // Wait for any session to complete before starting a new one
                    let shouldContinue = false;
                    yield this.activePromisesMutex.runExclusive(() => __awaiter(this, void 0, void 0, function* () {
                        if (this.activePromises.length >= this.maxConcurrentSessions) {
                            yield Promise.race(this.activePromises);
                            shouldContinue = true;
                        }
                    }));
                    if (shouldContinue)
                        continue;
                    let batch;
                    yield this.batchQueueMutex.runExclusive(() => {
                        batch = this.batchQueue.shift();
                    });
                    if (!batch || batch.length === 0)
                        break;
                    const promise = (() => __awaiter(this, void 0, void 0, function* () {
                        if (this.isHalted) {
                            this.client.log('Halt event received, skipping batch');
                            return;
                        }
                        let sessionId;
                        try {
                            // Check if there's an available session in the pool
                            yield this.sessionPoolMutex.runExclusive(() => {
                                if (this.sessionPool.length > 0) {
                                    sessionId = this.sessionPool.pop();
                                }
                            });
                            // Otherwise, create a new session
                            if (!sessionId) {
                                const { data: session, warnings, errors, } = yield this.client.sessions.create({
                                    configuration: this.sessionConfig,
                                });
                                sessionId = session.id;
                                this.handleErrorAndWarningResponses({ warnings, errors, sessionId, batch });
                            }
                            const queue = new WindowQueue_1.WindowQueue(this.maxWindowsPerSession, this.runEmitter, sessionId, this.client, this.operation, this.onError, this.isHalted);
                            const windowResults = yield queue.processInBatches(batch);
                            this.results.push(...windowResults);
                            // Return the session to the pool
                            yield this.sessionPoolMutex.runExclusive(() => {
                                if (!sessionId) {
                                    throw new Error('Missing sessionId, cannot return to pool');
                                }
                                this.sessionPool.push(sessionId);
                            });
                        }
                        catch (error) {
                            if (this.onError) {
                                yield this.handleErrorWithCallback({ originalError: error, batch, sessionId, callback: this.onError });
                            }
                            else {
                                // By default, log the error and continue
                                const urls = batch.map((url) => url.url);
                                this.logErrorForUrls(urls, error);
                            }
                            // Clean up the session in case of error
                            if (sessionId) {
                                this.safelyTerminateSession(sessionId);
                            }
                        }
                    }))();
                    yield this.activePromisesMutex.runExclusive(() => {
                        this.activePromises.push(promise);
                    });
                    // Remove the promise when it completes
                    promise.finally(() => __awaiter(this, void 0, void 0, function* () {
                        yield this.activePromisesMutex.runExclusive(() => {
                            const index = this.activePromises.indexOf(promise);
                            if (index > -1) {
                                this.activePromises.splice(index, 1);
                            }
                        });
                    }));
                }
                // Wait for all remaining sessions to complete
                yield Promise.allSettled(this.activePromises);
            }
            finally {
                this.processingPromisesCount--;
            }
        });
    }
    handleErrorWithCallback(_a) {
        return __awaiter(this, arguments, void 0, function* ({ originalError, batch, sessionId, callback, }) {
            // Catch any errors in the onError callback to avoid halting the entire process
            try {
                yield callback({
                    error: this.formatError(originalError),
                    operationUrls: batch,
                    sessionId,
                });
            }
            catch (newError) {
                this.client.error(`Error in onError callback: ${this.formatError(newError)}. Original error: ${this.formatError(originalError)}`);
            }
        });
    }
    logErrorForUrls(urls, error) {
        const message = `Error for URLs ${JSON.stringify(urls)}: ${this.formatError(error)}`;
        this.client.error(message);
    }
    safelyTerminateSession(sessionId) {
        // Do not await since we don't want to block the main thread
        this.client.sessions.terminate(sessionId).catch((error) => {
            this.client.error(`Error terminating session ${sessionId}: ${this.formatError(error)}`);
        });
    }
    formatError(error) {
        return error instanceof Error ? error.message : String(error);
    }
    handleErrorAndWarningResponses({ warnings, errors, sessionId, batch, }) {
        if (!warnings && !errors)
            return;
        const details = {
            sessionId,
            urls: batch,
        };
        if (warnings) {
            details.warnings = warnings;
            this.client.warn(`Received warnings creating session: ${JSON.stringify(details)}`);
        }
        // Log an object with the errors and the URL
        if (errors) {
            details.errors = errors;
            this.client.error(`Received errors creating session: ${JSON.stringify(details)}`);
        }
    }
}
exports.SessionQueue = SessionQueue;
