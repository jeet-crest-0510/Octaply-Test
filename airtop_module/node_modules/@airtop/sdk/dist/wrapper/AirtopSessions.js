"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirtopSessions = void 0;
const readable_stream_1 = require("readable-stream");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const Client_1 = require("../api/resources/sessions/client/Client");
const node_fetch_1 = __importDefault(require("node-fetch"));
class AirtopSessions extends Client_1.Sessions {
    constructor(_options, debug = false) {
        super(_options);
        this._options = _options;
        this.debug = debug;
    }
    log(message) {
        if (this.debug) {
            console.log(message);
        }
    }
    /**
     * @param {Airtop.SessionRestInputV1} request
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sessions.create()
     */
    create(request, requestOptions) {
        const _super = Object.create(null, {
            create: { get: () => super.create }
        });
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const createSessionResponse = yield _super.create.call(this, request, requestOptions);
            if (!createSessionResponse.data) {
                throw new Error('Error creating browser session');
            }
            if ((_a = request === null || request === void 0 ? void 0 : request.configuration) === null || _a === void 0 ? void 0 : _a.skipWaitSessionReady) {
                return createSessionResponse;
            }
            this.log(`session created:\n${JSON.stringify(createSessionResponse, null, 2)}`);
            try {
                const event = yield this.waitForSessionReady(createSessionResponse.data.id, requestOptions);
                if (!event) {
                    this.log('No browser created, timed out?');
                    throw new Error('Waiting for session ready timed out');
                }
                const getInfoResponse = yield this.getInfo(createSessionResponse.data.id, requestOptions);
                // Merge the createSessionResponse with any new data from getInfoResponse
                return Object.assign(Object.assign({}, createSessionResponse), { data: Object.assign(Object.assign({}, createSessionResponse.data), getInfoResponse.data) });
            }
            catch (e) {
                this.log(e);
                throw new Error(`Error creating a new browser ${e}`);
            }
        });
    }
    /**
     * Waits for a session to enter the 'running' status
     *
     * @param id - The ID of the session to wait for
     * @param requestOptions - Optional request configuration including timeout
     * @returns The session event indicating the session is ready, or null if timed out
     */
    waitForSessionReady(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const timeoutSeconds = (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) || 300;
            // Create a promise that resolves to null after the timeout
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => resolve(null), timeoutSeconds * 1000);
            });
            // Create a promise for the event processing
            const processEventsPromise = (() => __awaiter(this, void 0, void 0, function* () {
                var _a, e_1, _b, _c;
                const sessionEvents = yield this.events(id, {}, Object.assign({ timeoutInSeconds: timeoutSeconds }, (requestOptions || {})));
                try {
                    for (var _d = true, sessionEvents_1 = __asyncValues(sessionEvents), sessionEvents_1_1; sessionEvents_1_1 = yield sessionEvents_1.next(), _a = sessionEvents_1_1.done, !_a; _d = true) {
                        _c = sessionEvents_1_1.value;
                        _d = false;
                        const event = _c;
                        const e = event;
                        if (e.event === 'status') {
                            this.log(`status message received:\n${JSON.stringify(event, null, 2)}`);
                            if (e.status === 'running') {
                                return event;
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = sessionEvents_1.return)) yield _b.call(sessionEvents_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return null;
            }))();
            // Race the timeout against the event processing
            return Promise.race([timeoutPromise, processEventsPromise]);
        });
    }
    /**
     * Waits for a file to be downloaded in a session and reach 'available' status.
     * Defaults to looking back 5 seconds in the event stream for the file to be available.
     * Use `lookbackSeconds` to control this behavior.
     *
     * @param {string} sessionId - The ID of the session to monitor
     * @param {Object} configuration - The optional configuration parameters for the function
     * @param {number} [configuration.lookbackSeconds=5] - The number of seconds to look back for prior events. Default `5`. 0 means no lookback.
     * @param {Sessions.RequestOptions} [requestOptions] - Optional request configuration including timeout
     * @returns {Promise<{ id: string, downloadUrl: string } | null>} Object containing file's id and downloadUrl, or null if timed out
     */
    waitForDownload(sessionId, configuration, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { lookbackSeconds = 5 } = configuration || {};
            this.log(`waiting for file to be available on session: ${sessionId}`);
            const startTime = new Date();
            const timeoutSeconds = (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) || 120;
            // Create a promise that resolves to null after the timeout
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => {
                    this.log(`waiting for file timed out after ${timeoutSeconds} seconds`);
                    resolve(null);
                }, timeoutSeconds * 1000);
            });
            // Create a promise for the event processing
            const processEventsPromise = (() => __awaiter(this, void 0, void 0, function* () {
                var _a, e_2, _b, _c;
                const sessionEvents = yield this.events(sessionId, { all: lookbackSeconds >= 0 }, Object.assign({ timeoutInSeconds: timeoutSeconds }, (requestOptions || {})));
                try {
                    for (var _d = true, sessionEvents_2 = __asyncValues(sessionEvents), sessionEvents_2_1; sessionEvents_2_1 = yield sessionEvents_2.next(), _a = sessionEvents_2_1.done, !_a; _d = true) {
                        _c = sessionEvents_2_1.value;
                        _d = false;
                        const event = _c;
                        const e = event;
                        if (e.event === 'file_status') {
                            if (e.status === 'available') {
                                const eventTime = Date.parse(e.eventTime);
                                this.log(`file_status message received:\n${JSON.stringify(event, null, 2)}`);
                                const thresholdTime = startTime.getTime() - lookbackSeconds * 1000;
                                if (eventTime < thresholdTime) {
                                    this.log(`skipping file available event for ${e.fileId} because its timestamp is earlier than lookbackSeconds`);
                                    continue;
                                }
                                return {
                                    id: e.fileId,
                                    downloadUrl: e.downloadUrl,
                                };
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = sessionEvents_2.return)) yield _b.call(sessionEvents_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return null;
            }))();
            // Race the timeout against the event processing
            return Promise.race([timeoutPromise, processEventsPromise]);
        });
    }
    /**
     * Waits for a file download to start in a session.
     * Defaults to looking back 5 seconds in the event stream for the file to be available.
     * Use `lookbackSeconds` to control this behavior.
     *
     * @param {string} sessionId - The ID of the session to monitor
     * @param {Object} configuration - The optional configuration parameters for the function
     * @param {number} [configuration.lookbackSeconds=5] - The number of seconds to look back for prior events. Default `5`. 0 means no lookback.
     * @param {Sessions.RequestOptions} [requestOptions] - Optional request configuration including timeout
     * @returns {Promise<{ id: string, downloadUrl: string } | null>} Object containing file's id and downloadUrl, or null if timed out
     */
    waitForDownloadStart(sessionId, configuration, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { lookbackSeconds = 5 } = configuration || {};
            const startTime = new Date();
            const timeoutSeconds = (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) || 60;
            // Create a promise that resolves to null after the timeout
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => resolve(null), timeoutSeconds * 1000);
            });
            // Create a promise for the event processing
            const processEventsPromise = (() => __awaiter(this, void 0, void 0, function* () {
                var _a, e_3, _b, _c;
                const sessionEvents = yield this.events(sessionId, { all: lookbackSeconds >= 0 }, Object.assign({ timeoutInSeconds: timeoutSeconds }, (requestOptions || {})));
                try {
                    for (var _d = true, sessionEvents_3 = __asyncValues(sessionEvents), sessionEvents_3_1; sessionEvents_3_1 = yield sessionEvents_3.next(), _a = sessionEvents_3_1.done, !_a; _d = true) {
                        _c = sessionEvents_3_1.value;
                        _d = false;
                        const event = _c;
                        const e = event;
                        if (e.event === 'file_status') {
                            this.log(`file_status message received:\n${JSON.stringify(event, null, 2)}`);
                            if (e.status === 'uploading') {
                                const eventTime = Date.parse(e.eventTime);
                                const thresholdTime = startTime.getTime() - lookbackSeconds * 1000;
                                if (eventTime < thresholdTime) {
                                    this.log(`skipping file uploading event for ${e.fileId} because its timestamp is earlier than lookbackSeconds`);
                                    continue;
                                }
                                return {
                                    id: e.fileId,
                                    downloadUrl: e.downloadUrl,
                                };
                            }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = sessionEvents_3.return)) yield _b.call(sessionEvents_3);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return null;
            }))();
            // Race the timeout against the event processing
            return Promise.race([timeoutPromise, processEventsPromise]);
        });
    }
    /**
     * Downloads the next file from a session as soon as it starts to become available
     *
     * @param {string} sessionId - The ID of the session to download from
     * @param {string} destinationPath - The local path where the file should be saved
     * @param {Object} configuration - The optional configuration parameters for the function
     * @param {function} [configuration.onProgress] - Optional callback to track download progress
     * @param {number} [configuration.lookbackSeconds=5] - Optional number of seconds to look back for prior events. Default `5`. 0 means no lookback.
     * @param {number} [configuration.timeoutSeconds=120] - Optional timeout in seconds. Default `120`.
     * @param {Sessions.RequestOptions} [requestOptions] - Optional request configuration including timeout
     * @throws Error if no file is available to download within the timeout period
     */
    downloadNextFile(sessionId, destinationPath, configuration, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { onProgress = undefined, lookbackSeconds = 5, timeoutSeconds = 120 } = configuration || {};
            const nextFile = yield this.waitForDownload(sessionId, { lookbackSeconds }, Object.assign({ timeoutInSeconds: timeoutSeconds }, (requestOptions || {})));
            if (!nextFile) {
                throw new Error('No file to download within timeout');
            }
            const downloadResponse = yield (0, node_fetch_1.default)(nextFile.downloadUrl);
            if (!downloadResponse.ok) {
                throw new Error(`Failed to download file: ${downloadResponse.statusText}`);
            }
            const totalBytes = Number.parseInt((_a = downloadResponse.headers.get('content-length')) !== null && _a !== void 0 ? _a : '0', 10);
            let downloadedBytes = 0;
            fs.mkdirSync(path.dirname(destinationPath), { recursive: true });
            const fileStream = fs.createWriteStream(destinationPath);
            yield new Promise((resolve, reject) => {
                var _a, _b;
                if (onProgress && downloadResponse.body) {
                    // Create a transform stream to track progress
                    const progressStream = new readable_stream_1.Transform({
                        transform(chunk, encoding, callback) {
                            downloadedBytes += chunk.length;
                            onProgress(downloadedBytes, totalBytes);
                            callback(null, chunk);
                        },
                    });
                    downloadResponse.body.pipe(progressStream).pipe(fileStream);
                    progressStream.on('error', reject);
                }
                else {
                    // If no progress callback, pipe directly
                    (_a = downloadResponse.body) === null || _a === void 0 ? void 0 : _a.pipe(fileStream);
                }
                (_b = downloadResponse.body) === null || _b === void 0 ? void 0 : _b.on('error', reject);
                fileStream.on('finish', resolve);
            });
        });
    }
    /**
     * Waits for a file upload to become available to a session.
     *
     * @param sessionId - The session id for the file upload.
     * @param fileId - The file id for the file upload.
     * @param timeoutSeconds - The timeout in seconds.
     * @returns The event for the file upload.
     */
    waitForUploadAvailable(sessionId_1, fileId_1) {
        return __awaiter(this, arguments, void 0, function* (sessionId, fileId, timeoutSeconds = 300) {
            this.log(`waiting for uploaded file to be available on session: ${sessionId} ${fileId}`);
            // Create a promise that resolves to null after the timeout
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => resolve(null), timeoutSeconds * 1000);
            });
            // Create a promise for the event processing
            const processEventsPromise = (() => __awaiter(this, void 0, void 0, function* () {
                var _a, e_4, _b, _c;
                const sessionEvents = yield this.events(sessionId, { all: true }, { timeoutInSeconds: timeoutSeconds });
                try {
                    for (var _d = true, sessionEvents_4 = __asyncValues(sessionEvents), sessionEvents_4_1; sessionEvents_4_1 = yield sessionEvents_4.next(), _a = sessionEvents_4_1.done, !_a; _d = true) {
                        _c = sessionEvents_4_1.value;
                        _d = false;
                        const event = _c;
                        const e = event;
                        if (e.event === 'file_upload_status') {
                            if (e.fileId === fileId) {
                                if (e.status === 'available') {
                                    this.log(`uploaded file is now available on session: ${sessionId} ${fileId}`);
                                    return event;
                                }
                                if (e.status === 'upload_failed') {
                                    this.log(`upload failed: ${sessionId} ${fileId}`);
                                    throw new Error(`upload failed: ${e.eventData.error}`);
                                }
                            }
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = sessionEvents_4.return)) yield _b.call(sessionEvents_4);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                return null;
            }))();
            // Race the timeout against the event processing
            return Promise.race([timeoutPromise, processEventsPromise]);
        });
    }
    /**
     * Captcha event listener
     * Defaults to looking back 5 seconds in the event stream for the captcha event to be available.
     * Use `lookbackSeconds` to control this behavior.
     *
     * @param {string} sessionId - The ID of the session to monitor
     * @param {function} callback - The callback function to be called when a captcha event is received
     * @param {Object} configuration - The optional configuration parameters for the function
     * @param {number} [configuration.lookbackSeconds=5] - The number of seconds to look back for prior events. Default `5`. 0 means no lookback.
     * @param {Sessions.RequestOptions} [requestOptions] - Optional request configuration including timeout
     * @returns {function} - A function to stop listening for captcha events
     */
    onCaptchaEvent(sessionId, callback, configuration, requestOptions) {
        let lastCallbackPromise = Promise.resolve();
        const abortController = new AbortController();
        const startTime = new Date();
        const { lookbackSeconds = 5 } = configuration || {};
        const timeoutSeconds = (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) || 60;
        (() => __awaiter(this, void 0, void 0, function* () {
            var _a, e_5, _b, _c;
            const sessionEvents = yield this.events(sessionId, { all: lookbackSeconds >= 0 }, Object.assign(Object.assign({ timeoutInSeconds: timeoutSeconds }, requestOptions), { abortSignal: abortController.signal }));
            try {
                for (var _d = true, sessionEvents_5 = __asyncValues(sessionEvents), sessionEvents_5_1; sessionEvents_5_1 = yield sessionEvents_5.next(), _a = sessionEvents_5_1.done, !_a; _d = true) {
                    _c = sessionEvents_5_1.value;
                    _d = false;
                    const event = _c;
                    const e = event;
                    if (e.event === 'captcha-event') {
                        this.log(`captcha-event message received:\n${JSON.stringify(event, null, 2)}`);
                        const msg = e;
                        const eventTime = Date.parse(e.eventTime);
                        const thresholdTime = startTime.getTime() - lookbackSeconds * 1000;
                        if (eventTime < thresholdTime) {
                            this.log('skipping captcha event because its timestamp is earlier than lookbackSeconds');
                            continue;
                        }
                        lastCallbackPromise = lastCallbackPromise
                            .then(() => callback(msg))
                            .catch((error) => this.log(`Error in captcha callback: ${error}`));
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = sessionEvents_5.return)) yield _b.call(sessionEvents_5);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }))().catch((error) => {
            if (error.name !== 'AbortError') {
                this.log(`Error in event processing: ${error}`);
            }
        });
        return () => {
            abortController.abort();
        };
    }
}
exports.AirtopSessions = AirtopSessions;
